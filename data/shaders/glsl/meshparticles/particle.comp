#version 450
#extension GL_EXT_debug_printf : enable

#include "common_particle.h"
#include "gpu_cmd.h"

struct Particle
{
	vec4 pos;
	vec4 color;
};

struct AppendJob 
{
	vec2 screenPos;
};

layout(binding = 3) buffer AppendBuffer
{
   AppendJob appendJobs[];
};

layout(binding = 4) buffer ParticleBuffer
{
   Particle particles[];
};

layout (binding = 5) uniform sampler2D depthTexture;

layout(binding = 6) buffer SSBOGlobalData
{
   GlobalParticleData globalData;
};

layout(binding = 7) buffer SSBOGpuCmd
{
   GpuCmdBuffer gpuCmd;
};

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

float rand(vec2 xy, float seed)
{
	float PHI = 1.61803398874989484820459;  // ¦µ = Golden Ratio  
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

void main() 
{
	uint id = gl_GlobalInvocationID.x;

	if (id >= globalData.renderCount)
	{
		return;
	}

	Particle particle = particles[id];
	if (id >= globalData.cachedCount && id < globalData.cachedCount + globalData.newEmiitedCount)
	{
		// new particle emitted this frame

		uint jobId = id - globalData.cachedCount;
		AppendJob job = appendJobs[jobId];

		ivec2 screenPos = ivec2(job.screenPos.x, job.screenPos.y);
		float depth = texelFetch(depthTexture, screenPos, 0).r;

		particle.pos = vec4(screenPos.x, screenPos.y, 0.0, 1.0);
		particle.color = vec4(screenPos.x, screenPos.y, depth, 1.0);
	}
	else
	{
		// previous alived particle
		float rnd = rand(vec2(id, id), particleSystem.random);
		particle.color.a -= (rnd * particleSystem.speed);

		if (particle.color.a < 0.0)
		{
			particle.color.a = -0.01;
		}

		//debugPrintfEXT("id %d alpha %f delatT %f\n", id, particle.color.a, particleSystem.deltaT);
	}

	// barrier can only sync within work group, but it's safe here,
	// because what we want is to prevent read after write,
	// and particle index won't be greater than id

	barrier();

	float lifetime = particle.color.a;
	if (lifetime > 0)
	{
		// update particle buffer
		uint index = atomicAdd(globalData.particleIndex, 1);	
		particles[index] = particle;

		// update vertices count
		atomicAdd(gpuCmd.drawCmd.vertexCount, 1);
		gpuCmd.drawCmd.instanceCount = 1;
		gpuCmd.drawCmd.firstVertex = 0;
		gpuCmd.drawCmd.firstInstance = 0;
	}
}

