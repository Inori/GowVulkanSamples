#version 450
#extension GL_EXT_debug_printf : enable

#include "common_particle.h"
#include "gpu_cmd.h"

struct Particle
{
	vec4 pos;
	vec4 color;
};

struct AppendJob 
{
	vec2 screenPos;
};

layout(binding = 3) buffer AppendBuffer
{
   AppendJob appendJobs[];
};

layout(binding = 4) buffer ParticleBuffer
{
   Particle particles[];
};

layout(binding = 5) buffer SSBOGlobalData
{
   GlobalParticleData globalData;
};

layout(binding = 6) buffer SSBOGpuCmd
{
   GpuCmdBuffer gpuCmd;
};

layout (binding = 7) uniform sampler2D depthTexture;
layout (binding = 8) uniform sampler2D colorTexture;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

float rand(vec2 xy, float seed)
{
	float PHI = 1.61803398874989484820459;  // ¦µ = Golden Ratio  
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

vec3 ScreenToWorldPosition(vec2 screenPos)
{
	ivec2 iscreen = ivec2(screenPos.x, screenPos.y);

	float x = screenPos.x / viewData.viewport.x;
	float y = screenPos.y / viewData.viewport.y;
	float z = texelFetch(depthTexture, iscreen, 0).r;

	// scale to (-1.0, 1.0)
	x = mix(-1.0, 1.0, x);
	y = mix(-1.0, 1.0, y);
	z = mix(-1.0, 1.0, z);

	vec4 ndc = vec4(x, y, z, 1.0);
	vec4 positionMW = viewData.invViewProj * ndc;

	return positionMW.xyz / positionMW.w;
}

Particle initParticle(uint id, Particle particle)
{
	// new particle emitted this frame

	uint jobId = id - globalData.cachedCount;
	AppendJob job = appendJobs[jobId];

	vec2 uv = vec2( job.screenPos.x / viewData.viewport.x, job.screenPos.y / viewData.viewport.y );
	float gray = texture(colorTexture, uv).r;

	vec3 worldPos = ScreenToWorldPosition(job.screenPos);
	particle.pos = vec4(worldPos, 1.0);
	particle.color = vec4(gray, gray, gray, 1.0);

	return particle;
}

Particle animateParticle(uint id, Particle particle)
{
	float rnd = rand(vec2(id, id), particleSystem.random);
	/*
		animate particle position
	*/

	particle.pos.x += mix(-10.0, 10.0, rnd) * 0.0001;
	particle.pos.y += particleSystem.speed * 0.0001;
	//particle.pos.z += mix(-2.0, 2.0, rnd) * 0.0001;

	/*
		maintain particle lifetime
	*/

	
	particle.color.a -= (rnd * particleSystem.deltaT * particleSystem.speed);

	/*
	// read noise lifetime threshold
	vec2 uv = vec2( particle.pos.x / viewData.viewport.x, particle.pos.y / viewData.viewport.y );
	float threshold = texture(colorTexture, uv).r;

	// decrease lifetime
	particle.color.a -= particleSystem.speed * 0.0001;

	// if age is greater than threshold, hide the particle
	float age = 1.0 - particle.color.a;
	if (age > threshold)
	{
		particle.color.a = -1.0;
	}
	*/

	//debugPrintfEXT("rnd %f\n", rnd);
	return particle;
}

void main() 
{
	uint id = gl_GlobalInvocationID.x;

	if (id >= globalData.renderCount)
	{
		return;
	}

	Particle particle = particles[id];
	if (id >= globalData.cachedCount && id < globalData.cachedCount + globalData.newEmiitedCount)
	{
		particle = initParticle(id, particle);
	}
	else
	{
		particle = animateParticle(id, particle);
	}

	// barrier can only sync within work group, but it's safe here,
	// because what we want is to prevent read after write,
	// and particle index won't be greater than global id

	barrier();

	float lifetime = particle.color.a;
	if (lifetime > 0)
	{
		// update particle buffer
		uint index = atomicAdd(globalData.particleIndex, 1);	
		particles[index] = particle;

		// update vertices count
		// and construct draw command
		atomicAdd(gpuCmd.drawCmd.vertexCount, 1);
		gpuCmd.drawCmd.instanceCount = 1;
		gpuCmd.drawCmd.firstVertex = 0;
		gpuCmd.drawCmd.firstInstance = 0;
	}
}

