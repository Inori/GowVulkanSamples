#version 450
#extension GL_EXT_debug_printf : enable

#include "common_particle.h"
#include "gpu_cmd.h"

struct Particle
{
	vec4 pos;
	vec4 color;
};

struct AppendJob 
{
	vec2 screenPos;
};

layout(binding = 3) buffer AppendBuffer
{
   AppendJob appendJobs[];
};

layout(binding = 4) buffer ParticleBuffer
{
   Particle particles[];
};

layout(binding = 5) buffer SSBOGlobalData
{
   GlobalParticleData globalData;
};

layout(binding = 6) buffer SSBOGpuCmd
{
   GpuCmdBuffer gpuCmd;
};

layout (binding = 7) uniform sampler2D depthTexture;
layout (binding = 8) uniform sampler2D colorTexture;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

float rand(vec2 xy, float seed)
{
	float PHI = 1.61803398874989484820459;  // ¦µ = Golden Ratio  
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

Particle initParticle(uint id, Particle particle)
{
	// new particle emitted this frame

	uint jobId = id - globalData.cachedCount;
	AppendJob job = appendJobs[jobId];

	ivec2 screenPos = ivec2(job.screenPos.x, job.screenPos.y);
	float depth = texelFetch(depthTexture, screenPos, 0).r;

	vec2 uv = vec2( screenPos.x / viewport.x, screenPos.y / viewport.y );
	float gray = texture(colorTexture, uv).r;

	particle.pos = vec4(screenPos.x, screenPos.y, 0.0, 1.0);
	particle.color = vec4(gray, gray, gray, 1.0);

	return particle;
}

Particle animeParticle(uint id, Particle particle)
{
	vec2 uv = vec2( particle.pos.x / viewport.x, particle.pos.y / viewport.y );
	float alpha = texture(colorTexture, uv).r;

	particle.color.a -= particleSystem.speed;

	float age = 1.0 - particle.color.a;
	if (age > alpha)
	{
		particle.color.a = -0.01;
	}

	//debugPrintfEXT("id %d alpha %f delatT %f\n", id, particle.color.a, particleSystem.deltaT);
	return particle;
}

void main() 
{
	uint id = gl_GlobalInvocationID.x;

	if (id >= globalData.renderCount)
	{
		return;
	}

	Particle particle = particles[id];
	if (id >= globalData.cachedCount && id < globalData.cachedCount + globalData.newEmiitedCount)
	{
		particle = initParticle(id, particle);
	}
	else
	{
		particle = animeParticle(id, particle);
	}

	// barrier can only sync within work group, but it's safe here,
	// because what we want is to prevent read after write,
	// and particle index won't be greater than global id

	barrier();

	float lifetime = particle.color.a;
	if (lifetime > 0)
	{
		// update particle buffer
		uint index = atomicAdd(globalData.particleIndex, 1);	
		particles[index] = particle;

		// update vertices count
		atomicAdd(gpuCmd.drawCmd.vertexCount, 1);
		gpuCmd.drawCmd.instanceCount = 1;
		gpuCmd.drawCmd.firstVertex = 0;
		gpuCmd.drawCmd.firstInstance = 0;
	}
}

